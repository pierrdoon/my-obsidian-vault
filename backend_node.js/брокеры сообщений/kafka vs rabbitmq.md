[Оригинал статьи](https://habr.com/ru/companies/innotech/articles/698838/)

[[kafka|kafka]] vs [[RabbitMQ|rabbitmq]]

---

## Какие бывают виды общения?

Давайте разберёмся, какие виды общения нас окружают. Самый распространённый вариант — любой диалог. Кто-то N обращается к кому-то Y и высказывает ему мнение, ждёт ответа или обратную связь.

Пример, общение по телефону:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/39c/b55/606/39cb5560643aa0e4c9733e6c8c2747ff.png)

Или всё то же самое, только N, транслируя сообщение Y, не ждёт от него ответа. Да-да, бывают такие люди, которые только привыкли высказывать собственное мнение. Также, кстати, работают рекламные рассылки или push-уведомления на телефоне.

Работа системы оповещения:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/884/ca9/093/884ca90934f39a7935e0c8c2750b029e.png)

Есть варианты общения не напрямую, а через посредника. Например, N просит X запомнить сообщение и передать всем его друзьям. При этом N не знает, кто входит в круг друзей X. X передаёт сообщение всем друзьям — C, D, E.

Хороший пример — это работа мессенджера. Отправитель публикует сообщения в определённые группы, пользователи подписываются и читают их.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/7c3/c8b/57c/7c3c8b57c45c52727b0ef8efcc39036f.png)

В другом похожем варианте N записывает сообщение на карточке и отдаёт X. X складывает карточки в специальный ящик. Те у кого есть доступ, по очереди заглядывают в ящик и забирают каждый по одному сообщению. Одно сообщение, один получатель.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ca6/b6a/9dc/ca6b6a9dc08cc357622380ae57e6a4d6.png)

## Паттерны обмена информации

В компьютерном мире большинство приложений, сервисов, служб зачастую работают не сами по себе, а взаимодействуют, обмениваются данными друг с другом. Без общения задачи пользователей просто бы не выполнялись.

Существуют разные способы обмена, из классификации которых определяются паттерны. Выше в упрощённом виде были перечислены четыре основных паттерна общения, которые так же присущи программам:

- Request-Response (Запрос-Ответ);
    
- One-Way (Односторонний) или Fire and Forget (Отправил и забыл);
    
- Publish-Subscribe (Публикация-Подписка) или сокращённо Pub-Sub;
    
- Point-to-Point (Точка-Точка).
    

В интернете Request-Response — это работа HTTP: клиент выполняет запрос на сервер, ждёт и получает ответ. One-Way, когда приложение по сети отправляет UDP (User Datagram Protocol) пакет на сервер без ожидания ответа. Последние два варианта связаны с брокерами сообщений, но о них чуть позже.

Часто в рамках взаимодействия приложения используют паттерн Request-Response. Программы общаются напрямую синхронно друг с другом. У такого взаимодействия есть особенности:

- отправителю нужно знать адрес получателя;
    
- получатель должен быть доступен в момент вызова;
    
- из-за сбоя отправитель может никогда не дождаться ответа;
    
- отправитель блокируется в ожидании ответа.
    

C развитием технологий, микросервисной архитектуры, IoT и общим ростом количество программ, синхронный подход общения приложений перестал удовлетворять. Потребовались новые решения.

В паттернах Pub-Sub и Point-to-Point происходит асинхронное общение через посредника. При реализации таких паттернов у программ появляются возможности:

- осуществлять асинхронный обмен данными (отправитель не блокируется);
    
- отделять отправителя от получателя (отправитель ничего не знает о получателе);
    
- выполнять отложенную обработку сообщений. Получателю не нужно быть постоянно активным, можно читать сообщения в удобное время;
    
- делегировать ответственность за маршрутизацию и доставку сообщений третьей стороне;
    
- легко интегрироваться с системами, использующими различные платформы, языки и протоколы связи.
    

## Так кто такие брокеры?

Итак, на прошлых картинках под буквой X прятался брокер сообщений (Message Broker).

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c51/5b3/ac0/c515b3ac071692e4a61e6875d06b99fd.png)

Брокер сообщений — это программная система полностью или частично реализующая паттерны Pub-Sub и Point-to-Point. Взаимодействие программ через брокер упрощает процесс разработки. Нет необходимости в каждом сервисе реализовывать механизмы доставки, маршрутизации, хранения сообщений — всем этим занимается «посредник». Общение через «посредника» помогает навести порядок и внести ясность в потоки данных, а значит, упростить разработку и снизить вероятность появление ошибок.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6c7/110/fd9/6c7110fd9ad1a0bff00c0d4b83b86547.png)

Использование брокера оправдано, если:

- существуют задачи, выполнение которых требует много времени и ресурсов;
    
- не нужен немедленный результат;
    
- необходима координация работы большого количества сервисов (событийная модель общения);
    
- требуется повысить масштабируемость и отказоустойчивость системы.
    

### Гарантия доставки

Брокер берёт на себя ответственность за доставку сообщений получателям. При этом в цепочке передачи данных возможны сбои, приводящие к потере данных. В зависимости от того, как ведёт себя система при возникновении сбоев, определяются типы гарантий доставки:

- **At most once (Не более одного раза)**
    
    Самый простой вариант — отправка в стиле Fire and Forget (Отправил и забыл). Большая часть сообщений доходит до получателя, но часть теряется из-за сбоев.
    

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/205/6ba/34a/2056ba34a3f9e34d67a63fddfb82220b.png)

- **At least once (Хотя бы один раз)**
    
    Чтобы все данные достигли цели, могут предприниматься повторные отправки. Хотя бы одна попытка будет успешной. В таком случае сообщения не теряются, но могут дублироваться.
    
    Обычно реализуется через механизм подтверждений (ACK, acknowledgment). Сообщение повторяется, если не получено подтверждение о доставке. Возможны дубли, если подтверждение потерялось или не было отправлено из-за сбоя.
    

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/9b9/1ba/cb2/9b91bacb210aae9dccc80979c785fb09.png)

- **Exactly once (Строго один раз)**
    
    Самый труднодостижимый вариант —максимальная гарантия доставки. Сообщения никогда не теряются и не дублируются, каждое доставляется ровно один раз.
    

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ab2/275/1af/ab22751afc53db36474d1058f147bf8e.png)

### Очередь и Топик

Брокер, реализующий шаблон Point-to-Point, ассоциируется с термином Queue (Очередь). Сообщения отправителя попадают в очередь, получатель извлекает сообщения из очереди. После извлечения сообщение становится больше никому не доступными. Данные в очереди хранятся, пока они не будут прочитаны или не истечёт срок их действия.

В Pub-Sub ассоциируется с темой, топиком (Topic). Сообщения попадают в топик. Система распределяет каждое сообщение между всеми подписчиками топика (Broadcast, вещание). Сообщения могут храниться в топике, до тех пор, пока это необходимо для распространения данных между всеми подписчиками.

## Разнообразие брокеров в природе

Существует множество программных реализаций брокеров сообщений. Одни из самых известные:

- [RabbitMQ](https://www.rabbitmq.com/);
    
- [Apache Kafka](https://kafka.apache.org/);
    
- [ActiveMQ](https://activemq.apache.org/);
    
- [NATS](https://nats.io/);
    
- [IBM MQ](https://www.ibm.com/products/mq);
    
- [Kestrel](https://github.com/twitter-archive/kestrel);
    
- [NSQ](https://nsq.io/);
    
- [Amazon SQS](https://aws.amazon.com/ru/sqs/);
    
- [Redis Streams](https://redis.io/docs/data-types/streams/).
    

Каждая из реализаций может отличаться по характеристикам:

- масштабируемость, пропускная способность;
    
- отказоустойчивость, возможность восстановления данных в результате сбоя;
    
- кластеризация;
    
- поддержка моделей Pub-Sub и Point-to-Point;
    
- гарантия доставки сообщений;
    
- упорядоченная доставка сообщений;
    
- контроль доступа;
    
- открытость кода;
    
- поддерживаемые платформы.
    

Например, в программных решениях «Иннотех» активно используются, ставшие де-факто стандартом, брокеры сообщений Kafka и RabbitMQ. У этих брокеров есть определённые отличия и особенности работы. Разберём их в качестве примера для понимания специфики принципов работы.

### «Умный брокер, тупой потребитель»

RabbitMQ традиционный брокер сообщений с открытым исходным кодом, работающий как автономно, так и в составе кластера. Поддерживает обе модели Pub-Sub и Point-to-Point, протоколы AMQP, MQTT, STOMP и другие. Реализованы гарантии доставки сообщений At most once и At least once.

В случае At most once получается большая пропускная способность, так как данные обрабатываются в быстрой оперативной памяти. At least once надёжный в плане доставки, но менее скоростной в плане передачи данных вариант, потому что используется механизм подтверждений и запись на диск.

В упрощённом виде принципы работы RabbitMQ можно представить так: приложение-отправитель (Publisher) публикует сообщения в брокер, ссылаясь на его внутреннюю сущность Exchange (Обменник). Обменник в зависимости от типа и настроек перенаправляет сообщения в одну или более связанных с ним очередей (Queue). Приложения-подписчики (Consumer) держат постоянное TCP соединение с RabbitMQ и ждут сообщения из заданной очереди. Брокер отправляет (push), распределяет сообщения между подписчиками. Если у очереди несколько подписчиков, сообщения между ними распределяются равномерно. Если сообщение успешно обработано подписчиком, оно удаляется из очереди.

RabbitMQ может слать подтверждение отправителю после того, как сохранил его сообщение. Или ждать подтверждения от получателя об успешной обработке взятого из очереди сообщения.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d85/109/2c9/d851092c98d092e9d80091912741142b.png)

Принцип «Умный брокер, тупой потребитель» по отношению к RabbitMQ означает, что брокер берёт на себя много дополнительных действий. Например, следит за прочитанными сообщениями и удаляет их из очереди. Или сам организует процесс распределения сообщений между подписчиками

### «Тупой брокер, умный потребитель»

Apache Kafka программный Pub-Sub брокер с открытым исходным кодом. Помимо гарантий доставки At most once и At least once, поддерживает Exactly once (Строго один раз). Обычно используется в больших проектах, так как обладает большой пропускной способностью и отказоустойчивостью, превосходит по данным характеристикам RabbitMQ и многие другие брокеры. При этом имеет высокий порог вхождения, требователен к ресурсам.

Kafka можно представить, как распределённый, реплицируемый лог коммитов. Распределённый, так как он разворачивается в виде кластера нод (под управлением Apache Zookeeper). Реплицируемый, потому что все данные синхронизируются между нодами. Лог, входящие сообщения последовательно добавляются в журнал и остаются там неизменными, не удаляются при чтении, как это происходит в RabbitMQ.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/dfa/bbc/3ef/dfabbc3ef8cfaccbf2c99fcaceca0abb.png)

В Kafka отсутствует понятие очереди (Queue), приложения пишут или читают сообщения из партиционированных топиков (Topic). Если просто, то принцип работы такой: приложение-продюсер (Producer) отправляет сообщение в топик брокера, которое записывается в конец одной из его партиций (Partition). По умолчанию для распределения сообщений между партициями топика используется алгоритм Round-Robin. Отправитель может влиять на выбор партиции, передавая вместе с сообщением специальный ключ (Message Key).

Приложения-подписчики (Consumer) читают, вытягивают (pull) сообщения из заданного топика. Для каждого подписчика Kafka запоминает указатель на последнее прочитанное им сообщение (offset). Если приложение падает, то восстановившись может продолжать чтение с прежнего места или перемотать (rewind) offset в прошлое и прочитать данные повторно.

Для Kafka принцип «Тупой брокер, умный потребитель» означает, что, в отличие от RabbitMQ, он не занимается контролем и распределением сообщений. Потребители сами опрашивают брокер и решают, какие сообщения им читать, брокер только хранит данные.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fbd/a12/1ab/fbda121ab3fd238ab1ea4fba06b189ff.png)

Количество партиций в топике зависит от количества его конкурирующих подписчиков. Одно приложение не может читать данные из одной партиции в несколько потоков. Параллелизм достигается за счёт увеличения количества партиций, для каждого потока своя.

В RabbitMQ такой проблемы не существует. Брокер проталкивает (push) сообщения подписчикам и поэтому может сам балансировать, распределять данные между подписчиками очереди. С другой стороны, Push-механизм (Одно сообщение за один раз) менее продуктивный по сравнению с Pull в Kafka.

## Выбирая между Kafka и RabbitMQ

На самом деле, категорично сравнивать брокеры сообщений очень сложно. У всех существуют свои задачи и области применения. В случае с Apache Kafka и RabbitMQ это немного разный уровень, где лучшего не существует.

Kafka используется для обработки больших объёмов данных, сотен тысяч сообщений в секунду, которые подолгу хранятся на диске и много раз читаются сотнями или даже тысячами подписчиков. Kafka — это легко масштабируемая система, обладающая повышенной отказоустойчивостью, что очень важно в крупных проектах.

RabbitMQ более простой в установке и настройке, успешно справляется с асинхронным обменом данными в микросервисной архитектуре. Не требует дополнительных компонентов и затрат на дисковые ресурсы, так как все сообщения после чтения из очереди удаляются. По сравнению с Kafka обладает большими возможностями по настройке шаблонов обмена сообщениями. Отличный выбор, если нет завышенных требований к отказоустойчивости и пропускной способности.


---

Или [другая статья](https://habr.com/ru/companies/slurm/articles/666326/)

---


### В чем отличие брокера сообщений и системы Pub/Sub?

Брокеры сообщений – это модули ПО, благодаря которым приложения, службы и системы могут взаимодействовать и обмениваться информацией. Брокеры сообщений преобразуют сообщения от разных формальных протоколов обмена сообщениями, позволяя взаимозависимым службам напрямую «общаться» друг с другом, даже если они написаны на разных языках или работают на других платформах.

Брокеры сообщений валидируют, маршрутизируют, хранят и доставляют сообщения назначенным получателям. Брокеры действуют как посредники между приложениями, позволяя продюсерам отправлять сообщения, не зная о количестве, активности и местонахождении консьюмеров.

Pub/Sub или Publish/Subscribe – это схема распространения сообщений, которая позволяет продюсерам публиковать любое необходимое сообщение.

Дата-инженеры и дата-сайентисты называют Pub/Sub методом распространения в стиле вещания, когда между продюсером и консьюмерами существует связь «один ко многим».

### Что такое Apache Kafka?

Apache Kafka – это распределенная платформа потоковой передачи событий с открытым исходным кодом, обеспечивающая высокую пропускную способность. Написанная на Java и Scala, Кафка представляет собой шину сообщений системы Pub/Sub, ориентированную на потоки и воспроизведение данных с высокой интенсивностью. Кафка не полагается на очередь, а добавляет сообщения в журнал и оставляет их там до достижения предела хранения или тех пор, пока консьюмер не прочитает эти сообщения.

В Кафке применяется подход на основе pull модели, позволяющий пользователям запрашивать пакеты сообщений с определенных оффсетов. Пользователи могут использовать пакетную обработку сообщений для повышения пропускной способности и эффективной доставки сообщений.

Хотя Кафка поставляется только с Java-клиентом, существует специальный адаптер SDK, который позволяет создать свою особую системную интеграцию. Также существует постоянно пополняемый каталог проектов экосистемы сообщества и клиентов с открытым исходным кодом.

Кафка выпущена в 2011 году, поэтому этот инструмент можно назвать «новичком».

### Для чего используется Apache Kafka?

Apache Kafka лучше всего подходит для потоковой передачи от А к Б без сложной маршрутизации, но с максимальной пропускной способностью. Инструмент отлично справляется с event sourcing, потоковой обработкой и моделированием изменений в системе в качестве последовательности событий. Кафку также можно использовать для обработки данных при многоэтапной конвейерной обработке.

Кафка станет отличным решением, если вам нужен фреймворк для хранения, чтения, повторного чтения и анализа потоковых данных. Ее сильная сторона – обработка и анализ данных в реальном времени. Инструмент идеально подходит для постоянного хранения сообщений или для регулярно проверяемых систем.

### Что такое RabbitMQ?

RabbitMQ – это распределенный брокер сообщений с открытым исходным кодом, который обеспечивает эффективную доставку сообщений в рамках сложных сценариев маршрутизации. Этот инструмент называется «распределенным», потому что обычно работает как кластер узлов, где очереди распределяются (реплицируются) по узлам для обеспечения высокой доступности и отказоустойчивости.

В RabbitMQ применяется push модель: это помогает предотвратить перегрузку пользователей через ограничение предварительной выборки, настроенное консьюмером. Идеальный подход для обмена сообщениями с малой задержкой, который отлично работает с архитектурой RabbitMQ на основе очередей. Этот инструмент можно представить как почтовое отделение, которое получает, хранит и отправляет почту; только RabbitMQ принимает, хранит и передает сообщения с двоичными данными.

По умолчанию в RabbitMQ используется протокол AMQP 0.9.1, также существуют расширения для поддержки дополнительных протоколов: AMQP 1.0, HTTP, STOMP и MQTT. RabbitMQ официально поддерживает Elixir, Go, Java, JavaScript, .NET, PHP, Python, Ruby, Objective-C, Spring и Swift. Пользователям доступны различные инструменты разработки и клиенты, использующие расширения сообщества.

### Для чего используется RabbitMQ?

Разработчики используют RabbitMQ для обработки высокопроизводительных и надежных фоновых заданий, а также для интеграции и взаимодействия внутри приложений и между ними. Инструмент применяется для выполнения сложной маршрутизации к консьюмерам и интеграции нескольких приложений и служб с нетривиальной логикой маршрутизации.

RabbitMQ идеально подходит для веб-серверов, которым требуется быстрый запрос-ответ. Этот инструмент распределяет нагрузку между рабочими приложениями при высокой нагрузке (более 20 000 сообщений в секунду) и может обрабатывать фоновые задания или длительные задачи, такие как преобразование PDF, сканирование файлов или масштабирование изображений.

RabbitMQ эффективно работает с длительными задачами, надежно исполняющимися фоновыми заданиями, связью/интеграцией внутри приложений и между ними.

### Основные отличия Apache Kafka и RabbitMQ

Эти фреймворки подходят к процессу обмена сообщениями абсолютно по-разному, сильно отличаются и их возможности. В таблице продемонстрированы основные различия инструментов.

|   |   |   |
|---|---|---|
|Apache Kafka и RabbitMQ|**RabbitMQ**|**Apache Kafka**|
|Производительность|От 4000 до 10 000 сообщений в секунду|1 миллион сообщений в секунду|
|Хранение сообщений|На основе подтверждения|На основе политик (например, 30 дней)|
|Тип данных|Транзакционные данные|Операционные данные|
|Режим работы консьюмера|Умный брокер/тупой консьюмер|Тупой брокер/умный консьюмер|
|Топология|Обмен: прямой, Fan out, топик, на основе заголовков|Основана на системе Publish/Subscribe|
|Размер полезных данных|Без ограничений|По умолчанию – ограничение в 1 МБ|
|Примеры применения|Простые случаи|Массовая обработка данных/высокопроизводительная передача данных|

Подробнее о разнице между Apache Kafka и RabbitMQ:

- **Поток данных.** RabbitMQ использует определенный ограниченный поток данных. Продюсер создает и отправляет сообщения, а консьюмер их принимает. Apache Kafka использует неограниченный поток данных, при этом пары «ключ-значение» непрерывно передаются в назначенную тему.
    
- **Использование данных.** RabbitMQ отлично подходит для запросов пользователей и транзакционных данных, таких как создание и размещение заказов. Кафка лучше справляется с операционными данными, такими как технологические процессы, статистика аудита и сбора данных, активность системы.
    
- **Обмен сообщениями.** RabbitMQ отправляет пользователям сообщения, которые удаляются из очереди после их обработки и подтверждения. Кафка – это журнал. Он использует непрерывные цепочки сообщений, которые сохраняются в очереди до истечения срока хранения.
    
- **Модель проектирования.** RabbitMQ использует модель умный брокер/тупой консьюмер. Брокер последовательно доставляет сообщения консьюмерам и отслеживает их статус. Apache Kafka использует модель тупого брокера/умного консьюмера. Этот инструмент не отслеживает сообщения, которые прочитал каждый пользователь. Кафка запоминает только непрочитанные сообщения, сохраняя их в течение установленного периода времени. Консьюмеры должны самостоятельно следить за своей позицией в каждом журнале.
    
- **Топология.** RabbitMQ использует топологию обмена очереди: сообщения отправляются на обмен, откуда затем рассылаются в различные привязки очередей для использования консьюмерами. Кафка использует топологию Publish/Subscribe, отправляя сообщения через поток в соответствующие топики, которые затем потребляются пользователями в разных авторизованных группах.
    

### Apache Kafka и RabbitMQ: что стоит изучить в 2022 году?

Каждый инструмент хорошо справляются с определенным пулом задач, поэтому однозначного ответа на этот вопрос нет.

Изучайте Кафку, если ваша работа предполагает любой из следующих сценариев:

- Event sourcing или моделирование систем изменяются как последовательность событий
    
- Потоковая передача и многоэтапная конвейерная обработка данных
    
- Приложения, которым требуется история потоков сообщений с гарантиями доставки at least once в порядке секционирования
    
- Потоки с пропускной способностью не менее 110 000 событий в секунду, сложная маршрутизация или порядок секционирования at least once.
    

Изучайте RabbitMQ, если в вашей компании реализован какой-либо из этих сценариев:

- Детальное управление согласованностью/набором гарантий для каждого сообщения
    
- Сложная маршрутизация к пользователям/консьюмерам
    
- Приложения, которым требуются различные возможности обмена сообщениями типа Publish/Subscribe или взаимодействие типа точка-точка «запрос-ответ»
    
- Приложения, которые должны поддерживать устаревшие протоколы: STOMP, MQTT, AMQP, 0-9-1.
    

В зависимости от количества свободного времени и сил вы можете изучить и Apache Kafka, и RabbitMQ: такая стратегия расширит стек ваших навыков, улучшит гибкость в новой рабочей среде и повысит конкурентоспособность на рынке труда. Изучив оба инструмента, вы будете готовы ко всему.