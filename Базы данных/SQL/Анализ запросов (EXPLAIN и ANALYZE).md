
Анализ запросов с помощью команд **`EXPLAIN`** и **`EXPLAIN ANALYZE`** — это ключевой инструмент для оптимизации производительности SQL-запросов в PostgreSQL. Эти команды помогают понять, как СУБД выполняет запрос, какие ресурсы задействует, и выявить «узкие места». Разберем их подробно.

---

### **1. Команда `EXPLAIN`**
**Что делает?**  
Показывает **план выполнения запроса**, который строит оптимизатор PostgreSQL. Этот план включает:
- Последовательность операций (узлов): сканирование таблиц, использование индексов, соединения (JOIN), сортировку и т.д.
- **Оценочную стоимость** каждой операции (в условных единицах).
- Предполагаемое количество строк и размер данных.

**Пример:**
```sql
EXPLAIN SELECT * FROM users WHERE age > 30;
```

**Вывод (упрощенно):**
```
Seq Scan on users  (cost=0.00..15.50 rows=500 width=36)
  Filter: (age > 30)
```
- **Seq Scan** — полное сканирование таблицы.
- **cost=0.00..15.50** — начальная и конечная оценочная стоимость.
- **rows=500** — ожидаемое количество строк после фильтрации.

**Зачем использовать?**  
- Определить, используются ли индексы.
- Найти дорогие операции (например, полное сканирование больших таблиц).
- Проверить, корректны ли оценки оптимизатора.

---

### **2. Команда `EXPLAIN ANALYZE`**
**Что делает?**  
Не только показывает план запроса, но и **выполняет его**, добавляя **фактические метрики**:
- Реальное время выполнения каждой операции.
- Фактическое количество строк.
- Затраты времени на чтение данных, фильтрацию, сортировку и т.д.

**Пример:**
```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE age > 30;
```

**Вывод (упрощенно):**
```
Seq Scan on users  (cost=0.00..15.50 rows=500 width=36) (actual time=0.012..0.215 rows=480 loops=1)
  Filter: (age > 30)
  Rows Removed by Filter: 20
Planning Time: 0.045 ms
Execution Time: 0.235 ms
```
- **actual time** — реальное время в миллисекундах.
- **rows=480** — фактическое количество строк (оценка была 500).
- **Planning Time** — время на построение плана.
- **Execution Time** — общее время выполнения.

**Важно!**  
- Запрос **выполняется фактически**, поэтому на больших данных это может занять время.
- Не используйте `EXPLAIN ANALYZE` для запросов с side effects (например, изменяющих данные), если не уверены.

---

### **3. Ключевые элементы плана выполнения**
- **Типы операций (узлов):**
  - **Seq Scan** — сканирование всей таблицы.
  - **Index Scan / Index Only Scan** — использование индекса.
  - **Nested Loop** — вложенные циклы для JOIN.
  - **Hash Join / Merge Join** — другие методы соединения.
  - **Sort** — сортировка результатов.
  - **Aggregate** — агрегация (GROUP BY).

- **Метрики:**
  - **cost** — оценочная стоимость (чем меньше, тем лучше).
  - **rows** — ожидаемое/фактическое количество строк.
  - **width** — средний размер строки в байтах.
  - **actual time** — реальное время выполнения узла.

---

### **4. Как анализировать план?**
1. **Ищите самые дорогие узлы** (высокие значения `cost` или `actual time`).
2. **Проверьте, используются ли индексы.** Если вместо Index Scan идет Seq Scan, возможно, индекс отсутствует или оптимизатор считает его использование неэффективным.
3. **Сравнивайте оценки (rows) с реальными значениями.** Большие расхождения указывают на устаревшую статистику (поможет команда `ANALYZE`).
4. **Обращайте внимание на операции с большим количеством строк:** например, фильтрация после JOIN вместо использования условий в WHERE.

---

### **5. Пример оптимизации**
**Исходный запрос:**
```sql
EXPLAIN ANALYZE 
SELECT * FROM orders 
WHERE customer_id = 100 
ORDER BY order_date DESC;
```

**Проблема:** План показывает `Seq Scan` по таблице `orders` с последующей сортировкой (`Sort`).

**Решение:** Добавить индекс для `customer_id` и `order_date`:
```sql
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date DESC);
```

**Новый план:** `Index Scan` using `idx_orders_customer_date`, сортировка не требуется.

---

### **6. Дополнительные советы**
- **Обновляйте статистику:** Выполняйте `ANALYZE table_name;` после больших изменений в данных.
- **Используйте форматы вывода:** `EXPLAIN (FORMAT JSON)` или инструменты вроде pgAdmin, которые визуализируют план.
- **Тестируйте на реалистичных данных:** Оценки оптимизатора зависят от статистики, актуальной для ваших данных.

---

### **7. Предостережения**
- Не злоупотребляйте `EXPLAIN ANALYZE` на продакшене, особенно для тяжелых запросов.
- Помните, что порядок выполнения запроса может не совпадать с текстом SQL (оптимизатор перестраивает операции).

Анализ планов запросов требует практики, но даже базовое понимание `EXPLAIN` и `EXPLAIN ANALYZE` значительно упростит оптимизацию SQL-кода.