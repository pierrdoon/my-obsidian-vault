
[Оригинал статьи](https://habr.com/ru/companies/netologyru/articles/597275/)

---

Ошибки есть в каждом коде. Мы перевели гайд разработчика Айо Исайя, в котором он рассказывает о системе ошибок и о том, как их устранять.

Раз вы читаете эту статью, вы, конечно, знакомы с концепцией ошибок в программировании. Это ошибки в коде, они же баги, которые приводят к сбою или неожиданному поведению программы. В отличие от некоторых языков, таких как Go и Rust, где вы вынуждены взаимодействовать с потенциальными ошибками на каждом этапе пути, в JavaScript и Node.js можно обойтись без согласованной стратегии обработки ошибок.

Однако именно такая стратегия делает жизнь проще. Цель статьи — познакомить вас с этими шаблонами для создания, доставки и обработки потенциальных ошибок. Шаблоны помогут обнаружить и обработать потенциальные ошибки в коде до развёртывания.

### Что такое ошибки в Node.js

Ошибка в Node.js — это любой экземпляр объекта Error. Общие примеры включают встроенные классы ошибок: `ReferenceError`, `RangeError`, `TypeError`, `URIError`, `EvalError` и `SyntaxError`. Пользовательские ошибки также можно создать путём расширения базового объекта Error, встроенного класса ошибки или другой настраиваемой ошибки. При создании ошибок таким путём нужно передать строку сообщения, описывающую ошибку. К сообщению можно получить доступ через свойство `message` объекта. Объект `Error` также содержит свойства `name` и `stack`, которые указывают имя ошибки и точку в коде, в которой объект создаётся.

```js
const userError = new TypeError("Something happened!");

console.log(userError.name); // TypeError
console.log(userError.message); // Something happened!
console.log(userError.stack);
/*TypeError: Something happened!    
	at Object.<anonymous> (/home/ayo/dev/demo/main.js:2:19)    
	<truncated for brevity>    
	at node:internal/main/run_main_module:17:47 */
```

Функции объекта Error можно передать или вернуть из функции. Если бросить его с помощью `throw`, объект Error станет исключением. Когда вы передаёте ошибку из функции, она переходит вверх по стеку, пока исключение не будет поймано. В противном случае `uncaught exception` может обвалить всю работу.

### Как обработать ошибку

Оптимальный способ обработки ошибок функции JavaScript зависит от того, выполняет ли эта функция синхронную или асинхронную операцию. Рассмотрим четыре общих шаблона, позволяющих обрабатывать ошибки функций в Node.js.

#### Исключения

Чаще всего ошибки функций обрабатывают путём генерации. В этом случае ошибка становится исключением, после чего её можно поймать где-нибудь в стеке с помощью блока `try / catch`. Если у ошибки есть разрешение всплывать в стеке, не будучи перехваченной, она преобразуется в формат `uncaughtException`, что приводит к преждевременному завершению работы приложения. Например, встроенный метод `JSON.parse ()` выдаёт ошибку, если строковый аргумент не является допустимым объектом JSON.

```js
function parseJSON(data) {  
	return JSON.parse(data);
}

try {  
	const result = parseJSON('A string');
} catch (err) {  
	console.log(err.message); // Unexpected token A in JSON at position 0
}
```

Для использования этого шаблона в функциях нужно добавить ключевое слово `throw` перед экземпляром ошибки. Этот шаблон сообщения об ошибках и обработки идиоматичен для функций, выполняющих синхронные операции.

```js
function square(num) {  
	if (typeof num !== 'number') {    
		throw new TypeError(`Expected number but got: ${typeof num}`);  
	}  
	return num * num;
}

try {  
	square('8');
} catch (err) {  
	console.log(err.message); // Expected number but got: string
}
```

#### Колбэк с первым аргументом-ошибкой

Из-за своей асинхронной природы Node.js интенсивно использует функции колбэка для обработки большей части ошибок. Колбэк (обратный вызов) передаётся в качестве аргумента другой функции и выполняется, когда последняя завершает свою работу.

Node.js использует колбэк с первым аргументом-ошибкой в большинстве асинхронных методов, чтобы гарантировать проверку ошибок до результатов операции. Колбэк обычно является последним аргументом функции, инициирующей асинхронную операцию, и вызывается один раз при возникновении ошибки или получении результата:

```js
function (err, result) {}
```

Первый аргумент зарезервирован для объекта ошибки. Если ошибка возникает в ходе асинхронной операции, она доступна через аргумент `err` при неопределённом результате. Однако, если ошибки не возникает, `err` будет иметь значение `null` или `undefined`, а `result` будет содержать ожидаемый результат операции. Этот шаблон работает, если прочитать содержимое файла с помощью встроенного метода `fs.readFile ():`

```js
const fs = require('fs');
fs.readFile('/path/to/file.txt', (err, result) => {
  if (err) {
    console.error(err);
    return;
  }
  // Log the file contents if no error
  console.log(result);
});
```

Метод `readFile ()` использует колбэк в качестве своего последнего аргумента, который, в свою очередь, соответствует подписи функции «первая ошибка». В этом сценарии `result` включает в себя содержимое файла, который читается, если ошибки не возникает. В противном случае он определяется как `undefined`, а аргумент `err` заполняется объектом ошибки, содержащим информацию о проблеме: файл не найден или недостаточно полномочий.

Как правило, методы, использующие колбэк для обработки ошибок, не могут определить, насколько важна выявленная ошибка. Они возвращают ошибку пользователю для обработки. Важно контролировать поток содержимого колбэка, проверять функцию на наличие ошибки, прежде чем пытаться получить доступ к результату операции.

Чтобы использовать шаблон колбэка с первым аргументом-ошибкой в собственных асинхронных функциях, нужно принять функцию в качестве последнего аргумента и вызвать её:

```js
function square(num, callback) {  
	if (typeof callback !== 'function') {    
		throw new TypeError(`Callback must be a function. Got: ${typeof callback}`);  
	}  
	// simulate async operation  
	setTimeout(() => {    
		if (typeof num !== 'number') {      
		// if an error occurs, it is passed as the first argument to the callback      
			callback(new TypeError(`Expected number but got: ${typeof num}`));      
			return;    
		}    
	
		const result = num * num;    // callback is invoked after the operation completes with the result    
		callback(null, result);  
	}, 100);
}
```

Любой вызывающий функцию `square` должен пройти через колбэк, чтобы получить доступ к нужному результату или ошибке.

Не нужно непосредственно обрабатывать ошибку в функции колбэка. Её можно распространить вверх по стеку, передав на другой колбэк. Но сначала убедитесь, что вы не генерируете исключение внутри функции. Асинхронное исключение невозможно отследить, потому что окружающий блок `try / catch` завершается до выполнения колбэка. Следовательно, исключение будет распространяться на вершину стека, что приведёт к завершению работы приложения. Исключение — когда обработчик зарегистрирован для `process.on ('uncaughtException')`.

```js
try {
  square('8', (err, result) => {
    if (err) {
      throw err; // not recommended
    }
    console.log(result);
  });
} catch (err) {
  // This won't work
  console.error("Caught error: ", err);
}
```

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fc3/dbf/cf6/fc3dbfcf615d8f85ab6e08df66a008ee.png)

#### Отклонение обещаний

Обещания в JavaScript — это актуальный способ выполнения асинхронных операций в Node.js. Они предпочтительнее колбэков из-за лучшего потока, который соответствует современным способам анализа программ, особенно с шаблоном `async / await`. Любой API-интерфейс Node.js, использующий колбэки с ошибкой для асинхронной обработки ошибок, может быть преобразован в обещания с помощью встроенного метода `util.promisify ()`. Например, заставить метод `fs.readFile ()` использовать обещания можно так:

```js
const fs = require('fs');const util = require('util');const readFile = util.promisify(fs.readFile);
```

Переменная `readFile` — это версия `fs.readFile ()` с обещаниями, в которой отклонения обещаний используются для сообщения об ошибках. Эти ошибки можно отследить, связав метод `catch`:

```js
readFile('/path/to/file.txt')  .then((result) => console.log(result))  .catch((err) => console.error(err));
```

Также можно использовать обещанные API в функциях `async`. Так выглядит основной способ использования обещаний в современном JavaScript: в нём код читается как синхронный, и для обработки ошибок применяют знакомый механизм `try / catch`. Перед асинхронным запуском важно использовать `await`, чтобы обещание было выполнено или отклонено до того, как функция возобновит выполнение. При отклонении обещания выражение `await` выбрасывает отклонённое значение, которое впоследствии попадает в окружающий блок `catch`.

```js
(async function callReadFile() {
  try {
    const result = await readFile('/path/to/file.txt');
    console.log(result);
  } catch (err) {
    console.error(err);
  }
})();
```

Обещания можно использовать в асинхронных функциях, возвращая обещание из функции и помещая код функции в обратный вызов обещания. Если есть ошибка, её стоит отклонить (reject) с помощью объекта Error. В противном случае можно разрешить (resolve) обещание с результатом, чтобы оно было доступно в цепочке метода `.then` или напрямую как значение функции `async` при использовании `async / await`.

```js
function square(num) {  
	return new Promise((resolve, reject) => {    
		setTimeout(() => {      
			if (typeof num !== 'number') {        
				reject(new TypeError(`Expected number but got: ${typeof num}`));      
			}      
			const result = num * num;      
			resolve(result);    
		}, 100);  
	});
}

square('8')  
	.then((result) => console.log(result))  
	.catch((err) => console.error(err));
```

#### Источники событий

Другой шаблон, подходящий для работы с длительными асинхронными операциями, которые могут приводить к множественным ошибкам или результатам, — это возврат `EventEmitter` из функции и выдача события как для успешного, так и для неудачного случая:

```js
const { EventEmitter } = require('events');

function emitCount() {  
	const emitter = new EventEmitter();  
	let count = 0;  // Async operation  
	const interval = setInterval(() => {    
		count++;    
		if (count % 4 == 0) {      
			emitter.emit(        
				'error',        
				new Error(`Something went wrong on count: ${count}`)     
			);      
			return;    
		}    
		emitter.emit('success', count);    
		if (count === 10) {      
			clearInterval(interval);      
			emitter.emit('end');    
		}  
	}, 1000);  
	return emitter;
}
```

Функция `emitCount ()` возвращает новый эмиттер событий, который сообщает об успешном исходе в асинхронной операции. Она увеличивает значение переменной `count` и каждую секунду генерирует событие успеха и событие ошибки, если значение `count` делится на 4. Когда `count` достигает 10, генерируется событие завершения. Этот шаблон позволяет передавать результаты по мере их поступления вместо ожидания завершения всей операции.

Вот как можно отслеживать и реагировать на каждое из событий, генерируемых функцией `emitCount ()`:

```js
const counter = emitCount();

counter.on('success', (count) => {  
	console.log(`Count is: ${count}`);
});

counter.on('error', (err) => {  
	console.error(err.message);
});

counter.on('end', () => {  
	console.info('Counter has ended');
});
```

![](https://habrastorage.org/getpro/habr/upload_files/f38/0d3/26a/f380d326af0512314bfcbeddbfc28f3a.gif)

Функция колбэка для каждого прослушивателя событий выполняется независимо, как только событие генерируется. Событие ошибки (error) — это особый случай для Node.js, потому что при отсутствии прослушивателя процесс Node.js выходит из строя. Вы можете закомментировать прослушиватель событий ошибки выше и запустить программу, чтобы увидеть, что произойдёт.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/69a/668/e28/69a668e28d5d6b19a24357ac9776b9af.png)

### Расширение объекта ошибки

Необходимо создавать собственные пользовательские классы ошибок, чтобы лучше отражать разные типы ошибок: класс `ValidationError` для ошибок, возникающих при проверке пользовательского ввода, класс `DatabaseError` для операций с базами данных, `TimeoutError` для операций, для которых истекло назначенное им время ожидания.

Пользовательские классы ошибок, расширяющие объект `Error`, сохранят основные свойства ошибки: сообщение (`message`), имя (`name`) и стек (`stack`). Но у них есть собственные свойства. `ValidationError` можно улучшить, добавив значимые свойства — часть ввода, вызвавшую ошибку.

Вот как можно расширить встроенный объект `Error` в Node.js:

```js
class ApplicationError extends Error {  
	constructor(message) {    
		super(message);    // name is set to the name of the class    
		this.name = this.constructor.name;  
	}
}

class ValidationError extends ApplicationError {  
	constructor(message, cause) {    
		super(message);    
		this.cause = cause  
	}
}
```

Класс `ApplicationError` — общая ошибка, а класс `ValidationError` представляет любую ошибку, возникающую при проверке ввода данных пользователем. Он наследуется от класса `ApplicationError` и дополняет его свойством `cause` для указания ввода, вызвавшего ошибку. Пользовательские классы ошибки можно использовать, как и обычные:

```js
function validateInput(input) {  
	if (!input) {    
		throw new ValidationError('Only truthy inputs allowed', input);  
	}  
	return input;
}

try {  
	validateInput(userJson);
} catch (err) {  
	if (err instanceof ValidationError) {    
		console.error(`Validation error: ${err.message}, caused by: ${err.cause}`);    
		return;  
	}  
	
console.error(`Other error: ${err.message}`);}
```

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/787/0aa/291/7870aa291420761ec7706ef19dba5bee.png)

Ключевое слово `instanceof` следует использовать для проверки конкретного типа ошибки. Не используйте имя ошибки для проверки типа, как в `err.name === 'ValidationError'`: это не сработает, если ошибка получена из подкласса `ValidationError`.

### Типы ошибок

Типы ошибок можно разделить на две основные категории: ошибки программиста и операционные проблемы. К первому типу можно отнести неудачные или неправильные аргументы функции, в то время как временные сбои при работе с внешними API однозначно относятся ко второй категории.

#### Операционные ошибки

Операционные ошибки — это предсказуемые ошибки, которые возникают в процессе выполнения приложения. Это не обязательно баги, чаще это даже внешние обстоятельства, способные нарушить ход выполнения программы. В таких случаях можно полностью понять влияние ошибки на процессы:

- Запрос API не выполняется по какой-либо причине (например, сервер не работает или превышен лимит скорости).
    
- Соединение с базой данных потеряно, например, из-за неисправного сетевого соединения.
    
- ОС не может выполнить запрос на открытие файла или запись в него.
    
- Пользователь отправляет на сервер недопустимые данные: неверный номер телефона или адрес электронной почты.
    

#### Ошибки программиста

Ошибки программиста — это ошибки в логике или синтаксисе программы, которые можно исправить только путём изменения исходного кода. Ошибки этого типа невозможно обработать, потому что это недочёты в программе:

- Синтаксические ошибки: незакрытая фигурная скобка.
    
- Ошибки типа при попытке сделать что-то неправильное: выполнение операций с операндами несовпадающих типов.
    
- Неверные параметры при вызове функции.
    
- Ссылки на ошибки при неправильном написании имени переменной, функции или свойства.
    
- Попытка получить доступ к местоположению за концом массива.
    
- Неспособность обработать операционную ошибку.
    

### Обработка операционных ошибок

Операционные ошибки в большинстве случаев предсказуемы. Их обработка — это рассмотрение вероятности неудачного завершения операции, возможных причин и последствий. Рассмотрим несколько стратегий обработки операционных ошибок в Node.js.

#### Сообщить об ошибке в стек

Во многих случаях лучше остановить выполнение программы, очистить все незавершённые процессы и сообщить об ошибке в стек. Зачастую это единственный способ исправить ошибку, когда функция, в которой она возникла, находится дальше по стеку. 

#### Повторить операцию

Сетевые запросы к внешним службам иногда могут завершаться ошибкой, даже если запрос полностью верен. Это случается из-за сбоя и неполадках сети или перегрузке сервера. Можно повторить запрос несколько раз, пока он не будет успешно завершён или пока не будет достигнуто максимальное количество повторных попыток. Первое, что нужно сделать, — это определить, уместно ли повторить запрос. Если исходный код состояния HTTP ответа — 500, 503 или 429, повторте запрос через некоторое время.

Проверьте, присутствует ли в ответе HTTP-заголовок Retry-After. Он указывает на точное время ожидания перед выполнением последующего запроса. Если его нет, необходимо отложить последующий запрос и постепенно увеличивать временной промежуток для каждой повторной попытки. Этот метод известен как стратегия экспоненциального отката. Нужно ещё определить максимальное время задержки и число запросов до отказа от дальнейших попыток.

#### Отправить ошибку клиенту

По умолчанию пользователи вводят данные неправильно. Поэтому первое, что нужно сделать перед запуском каких-либо процессов, — проверить введённые данные и незамедлительно сообщить пользователю о любых ошибках. При обработке ошибок клиента обязательно включите всю информацию, необходимую для создания сообщения об ошибке и имеющую смысл для пользователя.

#### Прервать программу.

В случае неисправимых системных ошибок разумный выход — зарегистрировать ошибку и немедленно завершить работу программы. Если исключение невозможно исправить на уровне JavaScript, то, возможно, не получится корректно завершить работу сервера. Тогда нужен системный администратор, способный всё исправить.

### Предотвращение ошибок программиста

Ошибки программиста сами по себе не могут быть обработаны, потому что их причина в коде или в логике. Однако ошибаться можно реже.

#### Принять TypeScript

TypeScript — это строго типизированное надмножество JavaScript. Основная цель его проектирования — статическая идентификация потенциально ошибочных конструкций без штрафных санкций во время выполнения. Принимая TypeScript в проекте (с максимально возможными параметрами компилятора), можно устранить целый класс ошибок программиста в ходе компиляции.

Когда проект на TypeScript, такие ошибки, как `undefined` `is not a function`, синтаксические или ссылочные ошибки, исчезают из кодовой базы. Перенос на TypeScript можно выполнять постепенно. Для быстрой миграции есть инструмент [ts-migrate](https://github.com/airbnb/ts-migrate).

#### Определить поведение для неверных параметров

Многие ошибки возникают из-за передачи неверных параметров. Это может быть связано не только с очевидными ошибками, такими как передача строки вместо числа, но и с небольшими погрешностями, когда аргумент функции имеет правильный тип, но выходит за пределы диапазона, который функция способна обработать. Когда функция вызывается таким образом, она может выдать неверное значение, например `NaN`. Когда сбой обнаруживается, сперва трудно определить его причину.

При работе с неверными параметрами и определяйте их поведение, либо выдавая ошибку, либо возвращая специальное значение, такое как `null`, `undefined` или `-1`, когда проблема может быть решена локально. Первый вариант— это подход, используемый `JSON.parse ()`, который выдаёт исключение `SyntaxError`, если строка для синтаксического анализа недействительна. Второй вариант — метод `string.indexOf ()` . 

#### Автоматизированное тестирование

Автоматизированные наборы тестов повышает вероятность исправления ошибок. Тесты помогают выяснить, как функция работает с нетипичными значениями. Для модульного тестирования подходят среды, такие как [Jest](https://jestjs.io/) или [Mocha](https://mochajs.org/).

### Неперехваченные исключения и необработанные отклонения обещаний

Неперехваченные исключения и необработанные отклонения обещаний вызываются ошибками программиста. Событие `uncaughtException` генерируется, когда исключение не перехватывается до того как достигнет цикла обработки событий. При обнаружении неперехваченного исключения приложение немедленно выходит из строя. Для переопределения такого поведения всегда можно добавить обработчик события:

```js
// unsafe
process.on('uncaughtException', (err) => {  
	console.error(err);
});
```

Но неперехваченное исключение указывает на то, что приложение находится в неопределённом состоянии. Поэтому попытка возобновить работу в обычном режиме без восстановления после ошибки небезопасна и может привести к утечке памяти и зависанию сокетов. Лучше использовать обработчик `uncaught Exception` для очистки всех выделенных ресурсов, закрытия соединений и ведения лога ошибок для оценки перед завершением процесса.

```js
// better
process.on('uncaughtException', (err) => {  
	Honeybadger.notify(error); // log the error in a permanent storage  
	// attempt a gracefully shutdown  
	server.close(() => {    
		process.exit(1); // then exit  
	});  
	// If a graceful shutdown is not achieved after 1 second,  
	// shut down the process completely  
	setTimeout(() => {    
		process.abort(); // exit immediately and generate a core dump file  
	}, 1000).unref()
});
```

Событие `unhandledRejection` генерируется, когда отклонённое обещание не обрабатывается блоком `catch`. В отличие от `uncaughtException`, эти события не вызывают немедленного сбоя приложения. Однако необработанные отклонения обещаний сейчас признаны устаревшими и могут немедленно завершить процесс в следующих релизах Node.js. Отслеживать необработанные отклонения обещаний можно с помощью прослушивателя событий `unhandledRejection`:

```js
process.on('unhandledRejection', (reason, promise) => {  
	Honeybadger.notify({    
		message: 'Unhandled promise rejection',    
		params: {      
			promise,      
			reason,    
		},  
	});  
	
	server.close(() => {    
		process.exit(1);  
	});  
	
	setTimeout(() => {    
		process.abort();  
	}, 1000).unref()
});
```

Серверы необходимо запускать с помощью диспетчера процессов, который автоматически перезапустит их в случае сбоя. Распространённый вариант — [PM2](https://www.npmjs.com/package/pm2), но для Linux существуют также `systemd` и `upstart`, а пользователи Docker могут использовать собственную [политику перезапуска](https://docs.docker.com/engine/reference/run/#restart-policies---restart). По завершении всех процессов стабильное обслуживание будет восстановлено почти мгновенно, а у вас будт информация о неперехваченном исключении. Можно запутсить несколько процессов и применить балансировщик нагрузки для распределения входящих запросов. Это поможет предотвратить простои.

Централизованная отчётность об ошибках

Ни одна стратегия обработки ошибок не будет полной без надёжной стратегии ведения журнала ошибок. Когда происходит сбой, важно узаписать как можно больше информации о проблеме. Централизация логов позволяет оценить, что происходит в коде. 

[Honeybadger](https://www.honeybadger.io/tour/) предоставляет всё необходимое для отслеживания ошибок. Интегрируется так:

**Установите пакет**

Используйте npm для установки пакета:

`$ npm install @honeybadger-io/js --save`

**Импортируйте библиотеку**

Импортируйте библиотеку и настройте её с помощью ключа API, чтобы получать сообщения об ошибках:

```js
const Honeybadger = require('@honeybadger-io/js');
Honeybadger.configure({
  apiKey: '[ YOUR API KEY HERE ]'
});
Сообщите об ошибках
Метоодом notify ():
try {
  // ...error producing code
} catch(error) {
  Honeybadger.notify(error);
}
```

Просмотрите [полную документацию](https://docs.honeybadger.io/lib/javascript/integration/node.html) или ознакомьтесь с [образцом](https://github.com/honeybadger-io/crywolf-node) Node.js / Express на GitHub.